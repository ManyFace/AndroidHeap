#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dlfcn.h>

#define MAX_INDEX 9
#define NOTE_SIZE 0x80

char **notes;

void handle_cmd(int cmd, int note_index, const char * note,int note_size)
{
	switch (cmd)
	{
		case 0: //malloc
			notes[note_index]=(char *)malloc(NOTE_SIZE);
			memset(notes[note_index], 0, NOTE_SIZE);
			if (NULL != note && note_size > 0) //initial note
			{
				memcpy(notes[note_index], note, note_size);
			}
			break;
		case 1: //free
			free(notes[note_index]);
			notes[note_index]=NULL;
			break;
		case 2: //edit note
			if (NULL != note && note_size>0)
			{
				memcpy(notes[note_index], note, note_size);
			}
			break;
		default:
			break;
	}
}

void read_input(char * buf, int read_len, int buf_size)
{
	if (NULL == buf || read_len <= 0)
		return;
	memset(buf, 0, buf_size);
	int i = 0;
	char temp_char;
	while(1)
	{
		temp_char = getchar();
		if (i<read_len)
			buf[i] = temp_char;
		if (temp_char == 0xA)
			break;
		i++;
	}
}

uint32_t read_input_uint(char *buf, int read_len, int buf_size)
{
	read_input(buf, read_len, buf_size);
	return strtoul(buf, 0, 10);
}

int main()
{
	notes =(char **) malloc((MAX_INDEX+1)*4);

	char note[NOTE_SIZE*2];
	memset(note, 0, sizeof(note));

	while(1)
	{
		int cmd = 0, note_index = 0, note_len = 0;
		char input_buffer[0x1000];

		char usage[128]="usage: 0:malloc 1:free 2:edit 3:exit\ninput cmd and note index (eg:0,1 -> cmd=0,note_index=1):\n";
		write(STDOUT_FILENO, usage, strlen(usage));

		//read command
		read_input(input_buffer, sizeof(input_buffer), sizeof(input_buffer));
		sscanf(input_buffer, "%d,%d", &cmd, &note_index);

		if (cmd==3) //exit
			break;

		if (0 == cmd || 2 == cmd) //get note content inputed
		{
			//read note len
			write(STDOUT_FILENO, "input note len:\n", 16);
			note_len = read_input_uint(input_buffer, sizeof(input_buffer), sizeof(input_buffer));
			//read note content
			write(STDOUT_FILENO, "input note:\n", 12);
			read_input(note, note_len, sizeof(note));
		}

		handle_cmd(cmd, note_index, note, note_len);
	}

	return 0;
}
